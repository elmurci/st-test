diff --git a/node_modules/did-jwt/lib/index.module.js b/node_modules/did-jwt/lib/index.module.js
index a4f395f..6de0ebd 100644
--- a/node_modules/did-jwt/lib/index.module.js
+++ b/node_modules/did-jwt/lib/index.module.js
@@ -1,4 +1,4 @@
-import { toString, fromString, concat } from 'uint8arrays';
+import { toString as uint8ToString, fromString, concat } from 'uint8arrays';
 import { x25519, ed25519 } from '@noble/curves/ed25519';
 import { varint } from 'multiformats';
 import { encode, decode } from 'multibase';
@@ -14,11 +14,18 @@ import { xchacha20poly1305 } from '@noble/ciphers/chacha';
 import { randomBytes } from '@noble/hashes/utils';
 
 const u8a = {
-  toString,
+  toString: uint8ToString,
   fromString,
   concat
 };
+
+console.log("[uint8arrays] toString", u8a.toString);
+
 function bytesToBase64url(b) {
+  console.log("[bytesToBase64url*] debug", typeof b, JSON.stringify(b));
+  console.log("[bytesToBase64url] toString", u8a.toString(b, 'base64url'));
+  console.log("[bytesToBase64url] toString Stringified", JSON.stringify(u8a.toString(b, 'base64url')));
+  console.log('[bytesToBase64url] encoding', b, JSON.stringify(b));
   return u8a.toString(b, 'base64url');
 }
 function base64ToBytes(s) {
@@ -253,6 +260,7 @@ function hexToBytes(s, minLength) {
   return u8a.fromString(input.toLowerCase(), 'base16');
 }
 function encodeBase64url(s) {
+  console.log('[encodeBase64url] encoding', s);
   return bytesToBase64url(u8a.fromString(s));
 }
 function decodeBase64url(s) {
@@ -1977,6 +1985,7 @@ const createJWT = function (payload, {
   canonicalize
 }, header = {}) {
   try {
+    console.log('[createJWT] *************** (1)', payload, issuer, alg, signer, expiresIn, canonicalize);
     if (!signer) throw new Error('missing_signer: No Signer functionality has been configured');
     if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured');
     if (!header.typ) header.typ = 'JWT';
@@ -1998,6 +2007,7 @@ const createJWT = function (payload, {
       ...payload,
       iss: issuer
     };
+    console.log('[createJWT] *************** (2)', fullPayload);
     return createJWS(fullPayload, signer, header, {
       canonicalize
     });
@@ -2023,12 +2033,20 @@ const createJWT = function (payload, {
 const createJWS = function (payload, signer, header = {}, options = {}) {
   try {
     if (!header.alg) header.alg = defaultAlg;
+    console.log('[createJWS] *************** (header)', header);
+    console.log('[createJWS] *************** (payload)', payload);
+    console.log('[createJWS] *************** (options)', options);
     const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize);
     const signingInput = [encodeSection(header, options.canonicalize), encodedPayload].join('.');
+    console.log('[createJWS] *************** (encodedPayload)', encodeSection(payload, options.canonicalize), "***", encodedPayload);
+    console.log('[createJWS] *************** (signingInput)', encodeSection(header, options.canonicalize), "***", signingInput);
     const jwtSigner = SignerAlg(header.alg);
+    console.log('[createJWS] *************** (3)', jwtSigner);
     return Promise.resolve(jwtSigner(signingInput, signer)).then(function (signature) {
       // JWS Compact Serialization
       // https://www.rfc-editor.org/rfc/rfc7515#section-7.1
+      console.log('[createJWS] *************** (4)', signingInput, "***", JSON.stringify(signingInput));
+      console.log('[createJWS] *************** (5)', signature, "***", JSON.stringify(signature));
       return [signingInput, signature].join('.');
     });
   } catch (e) {
@@ -2043,6 +2061,7 @@ const defaultAlg = 'ES256K';
 const DID_JSON = 'application/did+json'; // eslint-disable-next-line @typescript-eslint/no-explicit-any
 
 function encodeSection(data, shouldCanonicalize = false) {
+  console.log('[encodeSection] *************** (0)', encodeBase64url(JSON.stringify(data)), "******", JSON.stringify(data));
   if (shouldCanonicalize) {
     return encodeBase64url(canonicalizeData(data));
   } else {
