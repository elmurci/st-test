diff --git a/node_modules/did-jwt/lib/index.module.js b/node_modules/did-jwt/lib/index.module.js
index a4f395f..84b93e3 100644
--- a/node_modules/did-jwt/lib/index.module.js
+++ b/node_modules/did-jwt/lib/index.module.js
@@ -13,23 +13,22 @@ import { bech32 } from '@scure/base';
 import { xchacha20poly1305 } from '@noble/ciphers/chacha';
 import { randomBytes } from '@noble/hashes/utils';
 
-const u8a = {
-  toString,
-  fromString,
-  concat
-};
 function bytesToBase64url(b) {
-  return u8a.toString(b, 'base64url');
+  console.log("[bytesToBase64url*] debug", typeof b, JSON.stringify(b));
+  console.log("[bytesToBase64url] toString", toString(b, 'base64url'));
+  console.log("[bytesToBase64url] toString Stringified", JSON.stringify(toString(b, 'base64url')));
+  console.log('[bytesToBase64url] encoding', b, JSON.stringify(b));
+  return toString(b, 'base64url');
 }
 function base64ToBytes(s) {
   const inputBase64Url = s.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
-  return u8a.fromString(inputBase64Url, 'base64url');
+  return fromString(inputBase64Url, 'base64url');
 }
 function base58ToBytes(s) {
-  return u8a.fromString(s, 'base58btc');
+  return fromString(s, 'base58btc');
 }
 function bytesToBase58(b) {
-  return u8a.toString(b, 'base58btc');
+  return toString(b, 'base58btc');
 }
 const SUPPORTED_PUBLIC_KEY_TYPES = {
   ES256: ['JsonWebKey2020', 'Multikey', 'EcdsaSecp256r1VerificationKey2019'],
@@ -189,7 +188,7 @@ function extractPublicKeyBytes(pk) {
 
 function bytesToMultibase(b, base = 'base58btc', codec) {
   if (!codec) {
-    return u8a.toString(encode(base, b), 'utf-8');
+    return toString(encode(base, b), 'utf-8');
   } else {
     const codecCode = typeof codec === 'string' ? supportedCodecs[codec] : codec;
     const prefixLength = varint.encodingLength(codecCode);
@@ -198,7 +197,7 @@ function bytesToMultibase(b, base = 'base58btc', codec) {
 
     multicodecEncoding.set(b, prefixLength); // add the original bytes
 
-    return u8a.toString(encode(base, multicodecEncoding), 'utf-8');
+    return toString(encode(base, multicodecEncoding), 'utf-8');
   }
 }
 /**
@@ -250,22 +249,23 @@ function hexToBytes(s, minLength) {
     input = input.padStart(paddedLength, '00');
   }
 
-  return u8a.fromString(input.toLowerCase(), 'base16');
+  return fromString(input.toLowerCase(), 'base16');
 }
 function encodeBase64url(s) {
-  return bytesToBase64url(u8a.fromString(s));
+  console.log('[encodeBase64url] encoding', s);
+  return bytesToBase64url(fromString(s));
 }
 function decodeBase64url(s) {
-  return u8a.toString(base64ToBytes(s));
+  return toString(base64ToBytes(s));
 }
 function bytesToHex(b) {
-  return u8a.toString(b, 'base16');
+  return toString(b, 'base16');
 }
 function bytesToBigInt(b) {
-  return BigInt(`0x` + u8a.toString(b, 'base16'));
+  return BigInt(`0x` + toString(b, 'base16'));
 }
 function stringToBytes(s) {
-  return u8a.fromString(s, 'utf-8');
+  return fromString(s, 'utf-8');
 }
 function toJose({
   r,
@@ -273,8 +273,8 @@ function toJose({
   recoveryParam
 }, recoverable) {
   const jose = new Uint8Array(recoverable ? 65 : 64);
-  jose.set(u8a.fromString(r, 'base16'), 0);
-  jose.set(u8a.fromString(s, 'base16'), 32);
+  jose.set(fromString(r, 'base16'), 0);
+  jose.set(fromString(s, 'base16'), 32);
 
   if (recoverable) {
     if (typeof recoveryParam === 'undefined') {
@@ -303,7 +303,7 @@ function fromJose(signature) {
   };
 }
 function toSealed(ciphertext, tag) {
-  return u8a.concat([base64ToBytes(ciphertext), tag ? base64ToBytes(tag) : new Uint8Array(0)]);
+  return concat([base64ToBytes(ciphertext), tag ? base64ToBytes(tag) : new Uint8Array(0)]);
 }
 function leftpad(data, size = 64) {
   if (data.length === size) return data;
@@ -1977,6 +1977,7 @@ const createJWT = function (payload, {
   canonicalize
 }, header = {}) {
   try {
+    console.log('[createJWT] *************** (1)', payload, issuer, alg, signer, expiresIn, canonicalize);
     if (!signer) throw new Error('missing_signer: No Signer functionality has been configured');
     if (!issuer) throw new Error('missing_issuer: No issuing DID has been configured');
     if (!header.typ) header.typ = 'JWT';
@@ -1998,6 +1999,7 @@ const createJWT = function (payload, {
       ...payload,
       iss: issuer
     };
+    console.log('[createJWT] *************** (2)', fullPayload);
     return createJWS(fullPayload, signer, header, {
       canonicalize
     });
@@ -2023,12 +2025,20 @@ const createJWT = function (payload, {
 const createJWS = function (payload, signer, header = {}, options = {}) {
   try {
     if (!header.alg) header.alg = defaultAlg;
+    console.log('[createJWS] *************** (header)', header);
+    console.log('[createJWS] *************** (payload)', payload);
+    console.log('[createJWS] *************** (options)', options);
     const encodedPayload = typeof payload === 'string' ? payload : encodeSection(payload, options.canonicalize);
     const signingInput = [encodeSection(header, options.canonicalize), encodedPayload].join('.');
+    console.log('[createJWS] *************** (encodedPayload)', encodeSection(payload, options.canonicalize), "***", encodedPayload);
+    console.log('[createJWS] *************** (signingInput)', encodeSection(header, options.canonicalize), "***", signingInput);
     const jwtSigner = SignerAlg(header.alg);
+    console.log('[createJWS] *************** (3)', jwtSigner);
     return Promise.resolve(jwtSigner(signingInput, signer)).then(function (signature) {
       // JWS Compact Serialization
       // https://www.rfc-editor.org/rfc/rfc7515#section-7.1
+      console.log('[createJWS] *************** (4)', signingInput, "***", JSON.stringify(signingInput));
+      console.log('[createJWS] *************** (5)', signature, "***", JSON.stringify(signature));
       return [signingInput, signature].join('.');
     });
   } catch (e) {
@@ -2043,6 +2053,7 @@ const defaultAlg = 'ES256K';
 const DID_JSON = 'application/did+json'; // eslint-disable-next-line @typescript-eslint/no-explicit-any
 
 function encodeSection(data, shouldCanonicalize = false) {
+  console.log('[encodeSection] *************** (0)', encodeBase64url(JSON.stringify(data)), "******", JSON.stringify(data));
   if (shouldCanonicalize) {
     return encodeBase64url(canonicalizeData(data));
   } else {
